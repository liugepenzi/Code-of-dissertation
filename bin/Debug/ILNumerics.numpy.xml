<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics.numpy</name>
    </assembly>
    <members>
        <member name="T:ILNumerics.ExtensionMethods">
            <summary>
            Importing this class / its namespace makes the array methods from the [numpy API] visible on suitable arrays. 
            </summary>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension index.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Sequential index of the element to retrieve, as if the elements were stored in row-major order. -A.S.NumberOfElements &lt;=d0&lt;A.S.NumberOfElements.</param>
            <returns>Copy of the element as located by the index argument <paramref name="d0"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>. However, the 
            element position is computed by assuming the elements to be laid-out sequentially in memory in row-major order. This function 
            handles arbitrary storage orders, though, using its strides to compute the actual element position in memory.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if d0 exceeds the number of elements in the array.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <returns>Copy of the element as located by the index arguments <paramref name="d0"/> and <paramref name="d1"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <returns>Copy of the element as located by the index arguments <paramref name="d0"/>...<paramref name="d2"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <returns>Copy of the element as located by the index arguments <paramref name="d0"/>...<paramref name="d3"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <returns>Copy of the element as located by the index arguments <paramref name="d0"/>...<paramref name="d4"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <param name="d5">Index into dimension #5.</param>
            <returns>Copy of the element as located by the index arguments <paramref name="d0"/>...<paramref name="d5"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Index into dimension #0.</param>
            <param name="d1">Index into dimension #1.</param>
            <param name="d2">Index into dimension #2.</param>
            <param name="d3">Index into dimension #3.</param>
            <param name="d4">Index into dimension #4.</param>
            <param name="d5">Index into dimension #5.</param>
            <param name="d6">Index into dimension #6.</param>
            <returns>Copy of the element as located by the index arguments <paramref name="d0"/>...<paramref name="d6"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64[])">
            <summary>
            [numpy API] Returns a single element from this array according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="dims">Indices into the dimensions of A, values can be negative.</param>
            <returns>Copy of the element as located by the indices given by <paramref name="dims"/>.</returns>
            <remarks><para>An index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1, where negative indices count backwards, starting from the last element index in dimension i.</para>
            <para>This function does not support the merging of trailing, unspecified dimensions as known from 
            <see cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/> or from 
            <see cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64)"/>.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            <para>Consequently, providing <paramref name="dims"/> as null or as empty array returns the first element of <paramref name="A"/> or 
            the only element for a scalar array <paramref name="A"/>. However, if <paramref name="A"/> is empty an <see cref="T:System.IndexOutOfRangeException"/> will be thrown.</para>
            <para>If <paramref name="dims"/> has exactly one element, this element is considered as the sequential/ linear index into the <see cref="M:ILNumerics.ExtensionMethods.flatten``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)">flattened</see> 
            array.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.GetValue(BaseArray&lt;bool&gt;, long, long, long, long, long, long, long)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the element location according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">The index into dimension #0.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support to expand the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the element location according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">The index into dimension #0.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support to expand the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the element location according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">The index into dimension #0.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support to expand the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the element location according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">The index into dimension #0.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support to expand the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,System.Int64,System.Int64,System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the element location according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">The index into dimension #0.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support to expand the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,System.Int64,System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the element location according to the provided dimension indices.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">The index into dimension #0.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range 0...A.S[i]-1.</para>
            <para>This function does not support to expand the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead.</para>
            <para>Unspecified dimension indices are assumed to be 0. Optional indices for virtual dimensions must be 0.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Int64,``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the sequential element location provided.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The ILNumerics n-dim array.</param>
            <param name="d0">Sequential index into the elements of the array. Assuming row-major storage order.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>The index for dimension i can be negative and must evaluate to an element position in the range -A.S.NumberOfElements...A.S.NumberOfElements-1.</para>
            <para>This function does not support expanding the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead when addressing any non-existing element.</para>
            <para><paramref name="d0"/> is the position of the element to be overwritten by assuming that the arrays elements are sequentially 
            laid-out in memory in row major order. This function handles arbitrary storage orders, though, by using its strides to compute the 
            actual element position in memory.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.itemset``1(ILNumerics.Core.Arrays.Mutable{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},ILNumerics.InArray{System.Int64},``0)">
            <summary>
            [numpy API] Replaces a single element of this array at the specified location.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The mutable ILNumerics n-dim array.</param>
            <param name="dims">Index array addressing the position of the element in <paramref name="A"/> to replace.</param>
            <param name="value">The single value to be copied to the element at the specified position.</param>
            <remarks><para>Elements in <paramref name="dims"/> can be negative and must evaluate to an existing element.</para>
            <para>This function does not support expanding the array for indices outside of the existing range (as SetValue() does). An 
            exception will be thrown instead when addressing any non-existing element.</para>
            <para>For <paramref name="dims"/> being null or empty the first element of <paramref name="A"/> is addressed. For numpy 
            scalars <paramref name="A"/> the only element stored is replaced.</para>
            <para>If <paramref name="dims"/> has a length of 1 the only element in <paramref name="dims"/> is considered the sequential
            /linear index into the flattened version of <paramref name="A"/>.</para>
            <para>
            This function handles arbitrary storage orders.</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if an index exceeds the allowed range of the corresponding dimension.</exception>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.GetItem(System.Int64)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.item``1(ILNumerics.BaseArray{``0},System.Int64[])"/>
            <seealso cref="!:ILNumerics.ExtensionMethods.SetValue&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;(Mutable&lt;T1, LocalT, InT, OutT, RetT, StorageT&gt;, T1, long, long, long, long, long, long, long)"></seealso>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.Double},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{ILNumerics.complex},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.UInt64},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.Int64},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.Int32},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.UInt32},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.Int16},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.UInt16},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.SByte},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.Byte},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.BaseArray{System.Single},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``2(ILNumerics.BaseArray{``0},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array from generic input array, specify element type and storage order. This function is provided for compatibility with generic array types. 
            </summary>
            <typeparam name="Tin">The element type of the input. Must be a non-nullable value type.</typeparam>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">This array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.astype``1(ILNumerics.Logical,System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Create a new array of specific element type and storage order based on this array.
            </summary>
            <typeparam name="Tout">The target element type. Must be a non-nullable value type.</typeparam>
            <param name="A">This array.</param>
            <param name="order">[Optional] Storage order for the target array. Choices: null (default) - auto, <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/> or <see cref="F:ILNumerics.StorageOrders.RowMajor"/>.</param>
            <returns>New array with the same shape as this array, having the element type converted to <typeparamref name="Tout"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.copy``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Nullable{ILNumerics.StorageOrders})">
            <summary>
            [numpy API] Returns a copy of this array, optionally determining the storage order.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] The destination storage order. Default: (null) - automatically determine the best (fastest) storage order. If no preferred storage order can be determined <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> is used.</param>
            <returns>Copy of this array or this array if no copy is necessary.</returns>
            <remarks>Due to the automatic memory management of ILNumerics this method is rarely required. </remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.C"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.fill``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},``0)">
            <summary>
            [numpy API] Overwrites all elements of <paramref name="A"/> with the same value <paramref name="scalar"/>.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <param name="A">The array.</param>
            <param name="scalar">The new value as scalar.</param>
            <remarks><para>This function alters the source array and is only available for mutable array types.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.flatten``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)">
            <summary>
            [numpy API] Returns a flattened copy of the source array. This is the same as <see cref="M:ILNumerics.ExtensionMethods.ravel``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)"/>. See remarks for details.
            </summary>
            <typeparam name="T1">Element type.</typeparam>
            <param name="A">The source array.</param>
            <param name="order">[Optional] The storage order of the array returned. Default: row major.</param>
            <returns>A new array having the same element number and -type as <paramref name="A"/> flattened to a vector.</returns>
            <remarks><para>This is the same as 'A.Reshape(-1,order)'. Note that in ILNumerics all arrays semantically behave 
            like copies.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ravel``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)">
            <summary>
            [numpy API] Returns a flattened copy of the source array. This is the same as <see cref="M:ILNumerics.ExtensionMethods.ravel``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)"/>. See remarks for details.
            </summary>
            <param name="A">The source array.</param>
            <param name="order">[Optional] The storage order of the array returned. Default: row major.</param>
            <returns>A new array having the same element number and -type as <paramref name="A"/> flattened to a vector.</returns>
            <remarks><para>This is the same as 'A.Reshape(-1,order)'. Note that in ILNumerics all arrays semantically behave 
            like copies.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.ravel``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.ravel``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)">
            <summary>
            [numpy API] Returns a flattened copy of the source array. This is the same as <see cref="M:ILNumerics.ExtensionMethods.flatten``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)"/>. See remarks for details.
            </summary>
            <typeparam name="T1"></typeparam>
            <param name="A">The input array.</param>
            <param name="order">[Optional] The storage order of the array returned. Default: row major.</param>
            <returns>A new array having the same element number and -type as <paramref name="A"/> flattened to a vector.</returns>
            <remarks><para>This is the same as 'A.Reshape(-1,order)'. Note that in ILNumerics all arrays semantically behave 
            like copies.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Arrays.ConcreteArray`6.Reshape(System.Int64,System.Nullable{ILNumerics.StorageOrders})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.flatten``1(ILNumerics.BaseArray{``0},ILNumerics.StorageOrders)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.real(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            [numpy API] Extract real parts from this array.
            </summary>
            <param name="A">Source array.</param>
            <returns>Array with the real parts of <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.real(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Extract real parts from this array.
            </summary>
            <param name="A">Source array.</param>
            <returns>Array with the real parts of <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.imag(ILNumerics.BaseArray{ILNumerics.complex})">
            <summary>
            [numpy API] Extract imaginary parts from this array.
            </summary>
            <param name="A">Source array.</param>
            <returns>Array with the imaginary parts of <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.imag(ILNumerics.BaseArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Extract imaginary parts from this array.
            </summary>
            <param name="A">Source array.</param>
            <returns>Array with the imaginary parts of <paramref name="A"/>.</returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.resize``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
            <summary>
            [numpy API] Resize this array. This may allocates new memory if the new size is larger than the current size.
            </summary>
            <param name="size">The new size. Vector of non-negative elements.</param>
            <remarks>The storage order of this array is retained after resize. By providign an empty array for <paramref name="size"/> a 
            scalar arrays is produced. The result respects the current setting of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="size"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException"> if the elements are not stored in a contiguous storage layout.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.transpose``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
            <summary>
            [numpy API] Returns a version of this array having the dimensions reordered according to <paramref name="axes"/>.
            </summary>
            <param name="axes">The new dimension indices order.</param>
            <returns>New array based on this array with the same number of elements but reordered dimensions.</returns>
            <remarks><para>This function does not alter the source array. Instead, it creates a lazy copy and reorders the 
            dimensions on the copy.</para></remarks>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.T"/>
            <seealso cref="M:ILNumerics.Size.GetShifted(System.Int32,System.Int64*)"/>
            <seealso cref="M:ILNumerics.Size.SwapDimensions"/>
            <seealso cref="M:ILNumerics.Size.GetPermuted(System.Int64*,System.UInt32*,System.UInt32)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.transpose``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5})">
            <summary>
            [numpy API] Returns a version of this array having the dimensions swapped (reversed).
            </summary>
            <returns>New array based on this array with the same number of elements but reordered dimensions.</returns>
            <remarks><para>This function does not alter the source array. Instead, it creates a lazy copy and reorders the 
            dimensions on the copy.</para></remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.transpose``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})"/>
            <seealso cref="P:ILNumerics.Core.Arrays.ConcreteArray`6.T"/>
            <seealso cref="M:ILNumerics.Size.GetShifted(System.Int32,System.Int64*)"/>
            <seealso cref="M:ILNumerics.Size.SwapDimensions"/>
            <seealso cref="M:ILNumerics.Size.GetPermuted(System.Int64*,System.UInt32*,System.UInt32)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.squeeze``6(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.InArray{System.Int64})">
            <summary>
            [numpy API] Remove specific or all singleton dimensions.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="LocalT"></typeparam>
            <typeparam name="InT"></typeparam>
            <typeparam name="OutT"></typeparam>
            <typeparam name="RetT"></typeparam>
            <typeparam name="StorageT"></typeparam>
            <param name="A">The array to be altered.</param>
            <param name="axes">[Optional] Array with axis definition. This holds the indices of the axes to be removed. Default: (null) or empty: remove all singleton dimensions.</param>
            <remarks><para>This function respect the value of <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>. Thus, 
            if <see cref="P:ILNumerics.Settings.ArrayStyle"/> is <see cref="F:ILNumerics.ArrayStyles.ILNumericsV4"/> (default) at least 2 dimensions will remain in the array.</para>
            </remarks>
            <exception cref="T:System.ArgumentException"> if any dimension index provided in <paramref name="axes"/> points to a non-singleton dimension.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.swapaxes``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.UInt32,System.UInt32)">
            <summary>
            [numpy API] Returns a similar array having two axes exchanged.
            </summary>
            <param name="A">The source array. Will not be changed.</param>
            <param name="axis1">The first axis.</param>
            <param name="axis2">The second axis.</param>
            <returns>An array having the same number of dimensions, number of elements and elements as <paramref name="A"/> with dimensions axis1 and axis2 exchanged.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="axis1"/> or <paramref name="axis2"/> are out of range of <see cref="!:A.Size.NumberOfDimensions"/>.</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)">
            <summary>
            [numpy API] Replaces elements of <paramref name="A"/> with <paramref name="values"/> at positions given by the sequential indices (flatten, row-major) <paramref name="indices"/>.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A"/>.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="IndT">Element type of indices. Must be numeric.</typeparam>
            <param name="A">The array storing the elements to be replaced.</param>
            <param name="indices">Index array. The shape is ignored. Values must be numeric and are read in row-major order.</param>
            <param name="values">Values array. The shape is ignored. Values are read in row-major order.</param>
            <param name="mode">[Optionl] Specifies how to handle index values in <paramref name="indices"/> which are out-of-range. Default: error.</param>
            <remarks>
            <para>This function has a similar effect as doing <c>A.flat[indices] = values</c> in numpyInternal. However, in ILNumerics the iterator 
            returned from <c>A.flat</c> is read-only. Use <see cref="M:ILNumerics.ExtensionMethods.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)"/> as 
            a replacement.</para>
            <para>Note that the values in <paramref name="indices"/> are considered <i>sequential</i> indices, i.e. they correspond to the 
            element position in a flattened array, where the flattening is performed in row-major order. For performance reasons and if 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.StorageOrder"/> is not <see cref="F:ILNumerics.StorageOrders.RowMajor"/> A is converted to row-major 
            storage layout first and remains in row-major storage after the function returns. Note further, that the conversion happens 
            proactively, and is not rolled back in case of errors during the iteration.</para>
            <para>Elements of <paramref name="indices"/> can be negative, which corresponds to indexing from the end of flattened <paramref name="A"/>.</para>
            <para>Repeated values in <paramref name="indices"/> lead to only the last corresponding value in <paramref name="values"/> to be stored 
            at the respective position in <paramref name="A"/>.</para>
            <para>If <paramref name="values"/> has more elements than are indices provided in <paramref name="indices"/> superfluent values are ignored. No exception 
            is thrown in this case. If <paramref name="values"/> has fewer elements than indices are provided in <paramref name="indices"/> existing values 
            are repeated as necessary.</para>
            <para>The <paramref name="mode"/> parameter determines what happens with indices laying outside of the bounds of A. The default value
            of <see cref="F:ILNumerics.PutModes.Raise"/> throws an <see cref="T:System.IndexOutOfRangeException"/> in this case. Two other options exist which bring the
            index back into the valid range: <see cref="F:ILNumerics.PutModes.Wrap"/> computes the modulus, <see cref="F:ILNumerics.PutModes.Clip"/> limits the indices to the allowed range. 
            Note that negative indices behave as usual (counting from the end of A) for modes <see cref="F:ILNumerics.PutModes.Raise"/> and <see cref="F:ILNumerics.PutModes.Wrap"/> only.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)"/> requires 
            the element type of <paramref name="A"/> to be value types (struct, commonly numeric).</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="mode"/> is <see cref="F:ILNumerics.PutModes.Raise"/> and any element 
            in <paramref name="indices"/> is out of the allowed range of [-A.S.NumberOfElements...&gt;= A.<see cref="P:ILNumerics.Size.NumberOfElements"/>].</exception>
            <exception cref="T:System.ArgumentException">if either of <paramref name="indices"/> or <paramref name="values"/> is null, 
            if <paramref name="values"/> is empty but <paramref name="indices"/> is not, 
            if the specified <paramref name="mode"/> cannot successfully be applied (for example, because <paramref name="A"/> is empty).</exception>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.repeat``7(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},System.Nullable{System.UInt32})">
            <summary>
            [numpy API] Repeat elements along a flattened array or a specific axis.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A"/>.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="IndT">Element type of <paramref name="repeats"/>. Must be an integer type.</typeparam>
            <param name="A">The array storing the elements to be repeated.</param>
            <param name="repeats">Counts for element repetitions.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) flatten A and repeat all values along dimension #0.</param>
            <remarks>
            <para>This function repeats elements of <paramref name="A"/> along a single dimension. By default, where no <paramref name="axis"/> 
            is defined <paramref name="A"/> is reshaped to a vector in row-major order and all elements are repeated according to <paramref name="repeats"/>.
            Otherwise, if an <paramref name="axis"/> was specified, repetitions are performed along that dimension only. In this case, the array returned
            has the same shape as <paramref name="A"/>, except that the working dimension <paramref name="axis"/> is enlarged.</para>
            <para>The shape of <paramref name="repeats"/> is ignored. Its values give the counts for each element along the axis <paramref name="axis"/>. 
            Values must be numeric, positive integers and are read in row-major order. If <paramref name="repeats"/> has exactly one element 
            all elements along the working dimension of <paramref name="A"/> are repeated by the same number. Alternatively, the length of <paramref name="repeats"/> 
            must match A.S[axis] to specify individual repetition counts for each element along the working dimension. Thus, if <paramref name="axis"/> is 
            null (default) <paramref name="repeats"/> can be a scalar or an array with 'A.S.NumberOfElements == repeats.S.NumberOfElements'.</para>
            <para>This function returns a new array and does not alter <paramref name="A"/> or any input parameters.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if any of the <paramref name="A"/> or <paramref name="repeats"/> is null</exception>
            <exception cref="T:System.ArgumentException">
            if <paramref name="axis"/> points to a virtual dimension; 
            if <paramref name="repeats"/> is not a numeric array, is of a shape which is not broadcastable to the length of the working dimension or 
            contains elements which are not convertible to positive integer values; 
            </exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.repeat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Nullable{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.repeat``6(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},System.Int64,System.Nullable{System.UInt32})">
            <summary>
            [numpy API] Repeat elements along a flattened array or a specific axis.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A"/>.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A"/>)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A"/>)</typeparam>
            <param name="A">The array storing the elements to be repeated.</param>
            <param name="repeats">Number of repetitions for all elements (scalar value).</param>
            <param name="axis">[Optional] The working dimension. Default: (null) flatten A and repeat all values along dimension #0.</param>
            <remarks>
            <para>This function repeats elements of <paramref name="A"/> along a single dimension. By default, where no <paramref name="axis"/> 
            is defined <paramref name="A"/> is reshaped to a vector in row-major order and all elements are repeated according to <paramref name="repeats"/>.
            Otherwise, if an <paramref name="axis"/> was specified, repetitions are performed along that dimension only. In this case, the array returned
            has the same shape as <paramref name="A"/>, except that the working dimension <paramref name="axis"/> is modified.</para>
            <para>The value of <paramref name="repeats"/> gives the counts for each element along the axis <paramref name="axis"/>. 
            This value must be a positive integer.</para>
            <para>This function returns a new array and does not alter <paramref name="A"/> or any input parameters.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="A"/> is null</exception>
            <exception cref="T:System.ArgumentException">
            if <paramref name="axis"/> points to a virtual dimension; 
            or if <paramref name="repeats"/> is negative. 
            </exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.repeat``7(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},System.Nullable{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sort(ILNumerics.Core.Arrays.Mutable{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Sort elements of <paramref name="A"/> inplace.
            </summary>
            <param name="A">Array to get sorted.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function works on the elements of <paramref name="A"/> directly. No copy will be made. Therefore, 
            it is only available for mutable arrays.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean,ILNumerics.OutArray{System.Double})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean,ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean,ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean,ILNumerics.OutArray{System.Single})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean,ILNumerics.OutArray{System.UInt64})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int32})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean,ILNumerics.OutArray{System.UInt32})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean,ILNumerics.OutArray{System.Int16})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean,ILNumerics.OutArray{System.UInt16})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean,ILNumerics.OutArray{System.SByte})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argsort(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean,ILNumerics.OutArray{System.Byte})">
            <summary>
            [numpy API] Computes the indices for elements of sorted <paramref name="A"/>.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (-1) sorts the last dimension.</param>
            <param name="descending">[Optional] Sort in descending order. Default: (false) sort in ascending order.</param>
            <param name="sorted">[Optional] Returns the sorted values of <paramref name="A"/> also. Default: (null) sorted values are not returned.</param>
            <remarks><para>The sort is performed in parallel, using the quicksort algorithm.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)"/> for details.</para>
            <para>This function internally creates a copy of <paramref name="A"/>. Therefore, the sorted values can be returned 
            without significant overhead.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.sort(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})">
            <summary>
            [numpy API] Computes indices of maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})">
            <summary>
            [numpy API] Computes the indices of maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum of the whole array.</param>
            <param name="values">[Optional] Returns the maximum values found from <paramref name="A"/> also. Default: (null) maximum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})">
            <summary>
            [numpy API] Computes indices of minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})">
            <summary>
            [numpy API] Computes the indices of minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the indices for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum of the whole array.</param>
            <param name="values">[Optional] Returns the minimum values found from <paramref name="A"/> also. Default: (null) minimum values are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.ExtensionMethods.nanargmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            <para>See <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/> for details.</para></remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes maximum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the maximum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the maximum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the maximum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.max(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the maximum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.max(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmax(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.maxall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Nullable{System.Int32},ILNumerics.OutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt64},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt64})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt32},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt32})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Int16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.UInt16},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Nullable{System.Int32},ILNumerics.OutArray{System.UInt16})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.SByte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.SByte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, recognizing NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.nanmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})">
            <summary>
            [numpy API] Computes minimum elements along the specified dimension of <paramref name="A"/>, ignoring NaNs.
            </summary>
            <param name="A">Array to compute the minimum(s) for. This is not altered.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) finds the minimum within the whole array.</param>
            <param name="indices">[Optional] Also return the indices of the minimum values found from <paramref name="A"/>. Default: (null) indices are not returned.</param>
            <remarks><para>Negative dimension specifier '<paramref name="axis"/>' will be shifted into the range of valid dimension indices. -1 
            corresponds to the last dimension.</para>
            <para><see cref="M:ILNumerics.ExtensionMethods.min(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Int64})"/> 
            prioritizes NaN values over non-NaN values. I.e.: if any of the elements is NaN the respective result value will be NaN also.  
            Conversely, <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>, 
            ignores NaN values and gives the minimum among the non-NaN values, if possible. This corresponds to the behavior of ILNumerics version 4, Matlab(R) a.s.f.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.min(ILNumerics.BaseArray{System.Byte},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.argmin(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Nullable{System.Int32},ILNumerics.OutArray{System.Byte})"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
            <seealso cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.minall(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.conj(ILNumerics.Core.Arrays.Mutable{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})">
            <summary>[numpy API] Conjugates complex elements inplace.</summary>
            <param name="A">Mutable input array.</param>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> inplace.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>Elements of the input array <paramref name="A"/> are directly altered. New memory is only used if the elements 
            of <paramref name="A"/> are currently shared with other arrays. Only in this case a copy is created automatically.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.conj(ILNumerics.Core.Arrays.Mutable{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}})">
            <summary>[numpy API] Conjugates complex elements inplace.</summary>
            <param name="A">Mutable input array.</param>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/> inplace.</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>Elements of the input array <paramref name="A"/> are directly altered. New memory is only used if the elements 
            of <paramref name="A"/> are currently shared with other arrays. Only in this case a copy is created automatically.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.round(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32)">
            <summary>[numpy API] Creates an array with elements of <paramref name="A"/>, rounded to the specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.round(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32)">
            <summary>[numpy API] Creates an array with elements of <paramref name="A"/>, rounded to the specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.round(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32)">
            <summary>[numpy API] Creates an array with elements of <paramref name="A"/>, rounded to the specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.round(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32)">
            <summary>[numpy API] Creates an array with elements of <paramref name="A"/>, rounded to the specified number of fractional digits.</summary>
            <param name="A">Input array.</param>
            <param name="decimals">[Optional] number of fractional digits to round to. Default: (0) round to integers.</param>
            <returns>Array of same size as A with elements of A rounded towards the nearest even integer value.</returns>
            <remarks><para>The operation is efficiently performed on all elements of the input array <paramref name="A"/>.</para>
            <para>The storage order of the array returned depends on the order of <paramref name="A"/>. If 
            <paramref name="A"/>.<see cref="P:ILNumerics.Size.IsContinuous"/> is <c>true</c> the array returned will have the same <see cref="P:ILNumerics.Size.StorageOrder"/> 
            as <paramref name="A"/>. Otherwise, the elements of the returned array will be reordered in the order defined by 
            <see cref="P:ILNumerics.Settings.DefaultStorageOrder"/> (default: <see cref="F:ILNumerics.StorageOrders.ColumnMajor"/>).</para>
            <para>The operation is performed in multiple threads, according to the current settings of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/>.</para>
            <para>The input array <paramref name="A"/> is not altered. However, if <paramref name="A"/>'s storage is suitable and not 
            shared by other arrays its memory will be used for the result and the operation is performed 'inplace'.</para></remarks>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the sum of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build sum along. Default: (null) sum all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Summing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the sum of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the sum of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the sum of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to sum elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)">
            <summary>
            [numpy API] Computes the cumulative sum of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative sum along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as <paramref name="A"/>.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para>Elements of <paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}})">
            <summary>
            [numpy API] Computes the cumulative sum for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative sums of all elements..</returns>
            <remarks><para>Empty arrays <paramref name="A"/> produce empty arrays of the same shape.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Creates an array based on the products of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build the products along. Default: (null) factorize all elements.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of factorizing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Factorizing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)">
            <summary>
            [numpy API] Creates a scalar array with the product of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the product of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Creates an array with the products of elements of <paramref name="A"/> along a specific dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to prod elements of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)">
            <summary>
            [numpy API] Computes the cumulative product of elements of <paramref name="A"/> along dimension <paramref name="axis"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axis"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">Dimension of <paramref name="A"/> to compute the cumulative product along. A negative value counts from the last dimension.</param>
            <returns>Array of the same shape as A.</returns>
            <remarks><para><paramref name="axis"/> must lay in the range of existing dimension indices.</para>
            <para><paramref name="axis"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axis"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}})"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.cumprod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}})">
            <summary>
            [numpy API] Computes the cumulative product for all elements of a flattened version of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <returns>Array of the same shape as <see cref="M:ILNumerics.ExtensionMethods.flatten(ILNumerics.BaseArray{System.Boolean},ILNumerics.StorageOrders)"/> with cumulative products of all elements.</returns>
            <seealso cref="M:ILNumerics.ExtensionMethods.cumsum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},``0)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Create an array based on the mean of elements of <paramref name="A"/>. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to build mean along. Default: (null) compute from flattened array.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Array with the result of summing elements of <paramref name="A"/> accordingly.</returns>
            <remarks><para>Reducing over virtual dimensions is allowed. The result corresponds to <paramref name="A"/> and has the same shape and the same elements.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions;</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)">
            <summary>
            [numpy API] Create a scalar array with the mean of all elements of <paramref name="A"/>. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A scalar array with the mean of all elements of <paramref name="A"/>.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Create an array with the mean of elements of <paramref name="A"/> along a single dimension. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension to compute the mean of <paramref name="A"/> along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>An array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.mean(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along specific dimensions being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for all elements of <paramref name="A"/> along the dimension '<paramref name="axis"/>' being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Double,ILNumerics.Array{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.RetArray{System.Double},ILNumerics.Core.StorageLayer.Storage{System.Double}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt64,ILNumerics.Array{System.UInt64},ILNumerics.InArray{System.UInt64},ILNumerics.OutArray{System.UInt64},ILNumerics.RetArray{System.UInt64},ILNumerics.Core.StorageLayer.Storage{System.UInt64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int64,ILNumerics.Array{System.Int64},ILNumerics.InArray{System.Int64},ILNumerics.OutArray{System.Int64},ILNumerics.RetArray{System.Int64},ILNumerics.Core.StorageLayer.Storage{System.Int64}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt32,ILNumerics.Array{System.UInt32},ILNumerics.InArray{System.UInt32},ILNumerics.OutArray{System.UInt32},ILNumerics.RetArray{System.UInt32},ILNumerics.Core.StorageLayer.Storage{System.UInt32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int32,ILNumerics.Array{System.Int32},ILNumerics.InArray{System.Int32},ILNumerics.OutArray{System.Int32},ILNumerics.RetArray{System.Int32},ILNumerics.Core.StorageLayer.Storage{System.Int32}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.UInt16,ILNumerics.Array{System.UInt16},ILNumerics.InArray{System.UInt16},ILNumerics.OutArray{System.UInt16},ILNumerics.RetArray{System.UInt16},ILNumerics.Core.StorageLayer.Storage{System.UInt16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Int16,ILNumerics.Array{System.Int16},ILNumerics.InArray{System.Int16},ILNumerics.OutArray{System.Int16},ILNumerics.RetArray{System.Int16},ILNumerics.Core.StorageLayer.Storage{System.Int16}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Byte,ILNumerics.Array{System.Byte},ILNumerics.InArray{System.Byte},ILNumerics.OutArray{System.Byte},ILNumerics.RetArray{System.Byte},ILNumerics.Core.StorageLayer.Storage{System.Byte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.SByte,ILNumerics.Array{System.SByte},ILNumerics.InArray{System.SByte},ILNumerics.OutArray{System.SByte},ILNumerics.RetArray{System.SByte},ILNumerics.Core.StorageLayer.Storage{System.SByte}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.fcomplex,ILNumerics.Array{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.RetArray{ILNumerics.fcomplex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.fcomplex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{ILNumerics.complex,ILNumerics.Array{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.RetArray{ILNumerics.complex},ILNumerics.Core.StorageLayer.Storage{ILNumerics.complex}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any``1(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},ILNumerics.BaseArray{``0},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> along specified dimensions '<paramref name="axes"/>' being non-zero. 
            </summary>
            <typeparam name="IndT">Element type for <paramref name="axes"/> parameter. Must be numeric.</typeparam>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axes">[Optional] Dimensions of <paramref name="A"/> to work along. Default: (null) considers all elements of <paramref name="A"/>, reducing to a scalar.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>A logical array with the same shape of <paramref name="A"/>, except dimensions listed in '<paramref name="axes"/>' which are reduced / expanded to length 1.</returns>
            <remarks><para>All dimension indices in <paramref name="axes"/> must be a valid, non-virtual dimension index from <paramref name="A"/>.</para>
            <para>Elements of <paramref name="axes"/> may be negative. Corresponding dimension indices are considered as counting from the end of the range of existing dimensions in <paramref name="A"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type (false).</para>
            <para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if elements of <paramref name="axes"/> are smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="keepdims">[Optional] accumulated dimensions remain in the resulting array. Default: (false) accumulated singleton dimensions are removed.</param>
            <returns>Logical scalar array with the result of testing for non-zero values.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/>.</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.any(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)">
            <summary>
            [numpy API] Tests for any elements of <paramref name="A"/> being non-zero. 
            </summary>
            <param name="A">The source array. This will not be altered.</param>
            <param name="axis">The dimension of <paramref name="A"/> to work along.</param>
            <param name="keepdims">[Optional] the reduced dimension <paramref name="axis"/> remains in the resulting array. Default: (false) the dimension <paramref name="axis"/> is removed from the result.</param>
            <returns>Logical array with the same shape of <paramref name="A"/>, except dimension '<paramref name="axis"/>' which is reduced / expanded to length 1.</returns>
            <remarks><para>Depending on the value of <paramref name="keepdims"/> the array returned will have the same number of dimensions as <paramref name="A"/> 
            (<paramref name="keepdims"/> = true) or with a number of dimensions according to <see cref="P:ILNumerics.Settings.MinNumberOfArrayDimensions"/> (<paramref name="keepdims"/> = false).</para>
            <para>Empty arrays <paramref name="A"/> produce a scalar array with the default element value for the element data type.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="axis"/> is smaller than -A.S.NumberOfDimensions or larger or equal to A.S.NumberOfDimensions.</exception>
            <seealso cref="M:ILNumerics.ExtensionMethods.all(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.prod(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Boolean)"/>
            <seealso cref="M:ILNumerics.ExtensionMethods.sum(ILNumerics.Core.Arrays.ConcreteArray{System.Single,ILNumerics.Array{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.RetArray{System.Single},ILNumerics.Core.StorageLayer.Storage{System.Single}},System.Int32,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.performARGMINMAXInternal``1(ILNumerics.Core.Arrays.ConcreteArray{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Nullable{System.Int32}@,ILNumerics.OutArray{``0},ILNumerics.StorageOrders,System.Boolean,System.Func{ILNumerics.Core.Arrays.ConcreteArray{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean,ILNumerics.RetArray{``0}},System.Func{ILNumerics.Core.Arrays.ConcreteArray{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean,ILNumerics.RetArray{``0}})">
            <summary>
            [numpy API] Helper function for [nan]arg[min|max] invokations.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="A"></param>
            <param name="axis"></param>
            <param name="values"></param>
            <param name="order"></param>
            <param name="ignoreNaNs"></param>
            <param name="func_all">Function delegate for accumulating all elements.</param>
            <param name="func_axis">Function delegate for accumulating axis-wise.</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.ExtensionMethods.performMINMAXInternal``1(ILNumerics.Core.Arrays.ConcreteArray{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},System.Nullable{System.Int32}@,ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean,System.Func{ILNumerics.Core.Arrays.ConcreteArray{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},ILNumerics.OutArray{System.Int64},ILNumerics.StorageOrders,System.Boolean,ILNumerics.RetArray{``0}},System.Func{ILNumerics.Core.Arrays.ConcreteArray{``0,ILNumerics.Array{``0},ILNumerics.InArray{``0},ILNumerics.OutArray{``0},ILNumerics.RetArray{``0},ILNumerics.Core.StorageLayer.Storage{``0}},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean,ILNumerics.RetArray{``0}})">
            <summary>
            [numpy API] Helper function for [nan][min|max] invokations.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="A"></param>
            <param name="axis"></param>
            <param name="indices"></param>
            <param name="order"></param>
            <param name="ignoreNaNs"></param>
            <param name="func_all">Function delegate for accumulating all elements.</param>
            <param name="func_axis">Function delegate for accumulating axis-wise.</param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.numpy">
            <summary>
            This class extends ILNumerics arrays with numpy semantics and gives access to further computational methods. 
            </summary>
        </member>
        <member name="M:ILNumerics.numpy.max(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.max(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.max(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.max(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the maximum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same maximum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.min(ILNumerics.BaseArray{System.Double},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same minimum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.min(ILNumerics.BaseArray{ILNumerics.fcomplex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same minimum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.min(ILNumerics.BaseArray{ILNumerics.complex},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same minimum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.min(ILNumerics.BaseArray{System.Single},ILNumerics.OutArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Computes the minimum of elements of <paramref name="A" /> along the specified dimension.
            </summary>
            <param name="A">Input array.</param>
            <param name="keepdim">[Optional] True: reduced singleton dimension is not removed from the output (default). False: the new singleton dimension is removed.</param>
            <param name="dim">The index of the dimension to be reduced.</param>
            <param name="I">[Optional] Output: 0-based index values of the found elements along the working dimension. Default: (null) don't return the indices.</param>
            <returns>New array with the same shape as <paramref name="A" /> except that the
            dimension specified by <paramref name="dim" /> is reduced to length min(1,A.S[dim]) and removed if <paramref name="keepdim" /> is false.</returns>
            <remarks><para>Empty arrays are handled in the same way as other shapes: the dimension specified by <paramref name="dim" /> is reduced to 1. If A.S[dim] == 0 the
            <paramref name="dim" />s dimension length in the array returned will also be 0.</para><para>Scalar arrays: numpy scalars give a numpy scalar (0 dim) as output.</para><para>Special floating point values (for floating point element types): positive and negative infinity are handled in the regular way. NaN ('not a number') values are ignored. If
            all elements in a working dimension are NaN, NaN is returned as result in the corresponding output element.</para><para>If the optional output parameter <paramref name="I" /> is not null on entry the function computes and returns the indices in <paramref name="A" /> of the
            values returned. Thus, <paramref name="I" /> has the same shape as the return array. If the storage of <paramref name="I" /> on entry is sufficient
            (i.e.: large enough and not shared with other arrays) it will be directly used for storing the indices and I is
            reshaped as required. Otherwise, a new array is created and returned. In order to safe the index computation
            null can be provided as <paramref name="I" /> which is the default.</para><para>If <paramref name="I" /> is requested and multiple elements along the working dimension in <paramref name="A" /> have the same minimum value it is undefined which
            element is 'picked' for the output. Hence, in this case the corresponding value in <paramref name="I" /> is undefined and may point to the first or any other occurrence of the
            value returned from the working dimension.</para></remarks>
            <exception cref="T:System.ArgumentException">If <c>A.S[dim] == 0</c> and <paramref name="keepdim" /> was false.</exception>
        </member>
        <member name="M:ILNumerics.numpy.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)">
            <summary>
            Replaces elements of <paramref name="A" /> with <paramref name="values" /> at positions given by sequential (i.e.: flatten, row-major) <paramref name="indices" />.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A" />.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="IndT">Element type of indices. Must be numeric.</typeparam>
            <param name="A">The array storing the elements to be replaced.</param>
            <param name="indices">Index array. The shape is ignored. Values must be numeric and are read in row-major order.</param>
            <param name="values">Values array. The shape is ignored. Values are read in row-major order.</param>
            <param name="mode">[Optionl] Specifies how to handle index values in <paramref name="indices" /> which are out-of-range. Default: error.</param>
            <remarks><para>This function has a similar effect as doing <c>A.flat[indices] = values</c> in numpy. However, in ILNumerics the iterator
            returned from <c>A.flat</c> is read-only. Use <see cref="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)" /> as
            a replacement.</para><para>Note that the values in <paramref name="indices" /> are considered <i>sequential</i> indices, i.e. they correspond to the
            element position in a flattened array, where the flattening is performed in row-major order. For performance reasons and if
            <paramref name="A" />.<see cref="P:ILNumerics.Size.StorageOrder" /> is not <see cref="F:ILNumerics.StorageOrders.RowMajor" /> A is converted to row-major
            storage layout first and remains in row-major storage after the function returns. Note further, that the conversion happens
            proactively, and is not rolled back in case of errors during the iteration.</para><para>Elements of <paramref name="indices" /> can be negative, which corresponds to indexing from the end of flattened <paramref name="A" />.</para><para>Repeated values in <paramref name="indices" /> lead to only the last corresponding value in <paramref name="values" /> to be stored
            at the respective position in <paramref name="A" />.</para><para>If <paramref name="values" /> has more elements than are indices provided in <paramref name="indices" /> superfluent values are ignored. No exception
            is thrown in this case. If <paramref name="values" /> has fewer elements than indices are provided in <paramref name="indices" /> existing values
            are repeated as necessary.</para><para>The <paramref name="mode" /> parameter determines what happens with indices laying outside of the bounds of A. The default value
            of <see cref="F:ILNumerics.PutModes.Raise" /> throws an <see cref="T:System.IndexOutOfRangeException" /> in this case. Two other options exist which bring the
            index back into the valid range: <see cref="F:ILNumerics.PutModes.Wrap" /> computes the modulus, <see cref="F:ILNumerics.PutModes.Clip" /> limits the indices to the allowed range.
            Note that negative indices behave as usual (counting from the end of A) for modes <see cref="F:ILNumerics.PutModes.Raise" /> and <see cref="F:ILNumerics.PutModes.Wrap" /> only.</para><para><see cref="M:ILNumerics.Core.Functions.Builtin.numpyInternal.put``7(ILNumerics.Core.Arrays.Mutable{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},ILNumerics.InArray{``0},ILNumerics.PutModes)" /> requires
            the element type of <paramref name="A" /> to be value types (struct, commonly numeric).</para></remarks>
            <exception cref="T:System.IndexOutOfRangeException"> if <paramref name="mode" /> is <see cref="F:ILNumerics.PutModes.Raise" /> and any element
            in <paramref name="indices" /> is out of the allowed range of [-A.S.NumberOfElements...&gt;= A.<see cref="P:ILNumerics.Size.NumberOfElements" />].</exception>
            <exception cref="T:System.ArgumentException">if either of <paramref name="indices" /> or <paramref name="values" /> is null,
            if <paramref name="values" /> is empty but <paramref name="indices" /> is not,
            if the specified <paramref name="mode" /> cannot successfully be applied (for example, because <paramref name="A" /> is empty).</exception>
        </member>
        <member name="M:ILNumerics.numpy.repeat``7(ILNumerics.Core.Arrays.ConcreteArray{``0,``1,``2,``3,``4,``5},ILNumerics.BaseArray{``6},System.Nullable{System.UInt32})">
            <summary>
            Repeat elements along a flattened array or a specific axis.
            </summary>
            <typeparam name="T1">Element type of <paramref name="A" />.</typeparam>
            <typeparam name="LocalT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="InT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="OutT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="RetT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="StorageT">(subtype of <paramref name="A" />)</typeparam>
            <typeparam name="IndT">Element type of <paramref name="repeats" />. Must be an integer type.</typeparam>
            <param name="A">The array storing the elements to be repeated.</param>
            <param name="repeats">Counts for element repetitions.</param>
            <param name="axis">[Optional] The working dimension. Default: (null) flatten A and repeat all values along dimension #0.</param>
            <remarks><para>This function repeats elements of <paramref name="A" /> along a single dimension. By default, where no <paramref name="axis" />
            is defined <paramref name="A" /> is reshaped to a vector in row-major order and all elements are repeated according to <paramref name="repeats" />.
            Otherwise, if an <paramref name="axis" /> was specified, repetitions are performed along that dimension only. In this case, the array returned
            has the same shape as <paramref name="A" />, except that the working dimension <paramref name="axis" /> is enlarged.</para><para>The shape of <paramref name="repeats" /> is ignored. Its values give the counts for each element along the axis <paramref name="axis" />.
            Values must be numeric, positive integers and are read in row-major order. If <paramref name="repeats" /> has exactly one element
            all elements along the working dimension of <paramref name="A" /> are repeated by the same number. Alternatively, the length of <paramref name="repeats" />
            must match A.S[axis] to specify individual repetition counts for each element along the working dimension. Thus, if <paramref name="axis" /> is
            null (default) <paramref name="repeats" /> can be a scalar or an array with 'A.S.NumberOfElements == repeats.S.NumberOfElements'.</para><para>This function returns a new array and does not alter <paramref name="A" /> or any input parameters.</para></remarks>
            <exception cref="T:System.ArgumentNullException"> if any of the <paramref name="A" /> or <paramref name="repeats" /> is null</exception>
            <exception cref="T:System.ArgumentException">
            if <paramref name="axis" /> points to a virtual dimension;
            if <paramref name="repeats" /> is not a numeric array, is of a shape which is not broadcastable to the length of the working dimension or contains elements which are not convertible to positive integer values;
            </exception>
        </member>
        <member name="P:ILNumerics.numpy.Version">
            <summary>
            Gets the version of this module [readonly].
            </summary>
        </member>
    </members>
</doc>
